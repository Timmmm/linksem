open import Basic_classes
open import Bool
open import List
open import Num
open import Show
open import String

open import Error
open import Maybe

open import Abi_utilities
open import Abis
open import Assert_extra
open import Auxv
open import Byte_sequence
open import Elf_dynamic
open import Elf_file
open import Elf_header
open import Elf_interpreted_section
open import Elf_interpreted_segment
open import Elf_memory_image_of_elf64_file
open import Elf_note
open import Elf_program_header_table
open import Elf_relocation
open import Elf_section_header_table
open import Elf_symbol_table
open import Elf_types_native_uint
open import Filesystem
open import Gnu_ext_abi
open import Gnu_ext_dynamic
open import Gnu_ext_program_header_table
open import Gnu_ext_section_header_table
open import Harness_interface
open import Ldconfig
open import Memory_image
open import Missing_pervasives

open import Abi_mips64
open import Abi_mips64_dynamic
open import Abi_mips64_relocation

open import Abi_amd64
open import Abi_amd64_relocation

(** A mmap table entry suitable for both Linux and FreeBSD. *)
type mmap_entry = <|
  mmap_entry_start : natural;
  mmap_entry_end : natural;
  mmap_entry_offset : natural;
  mmap_entry_path : string
|>

let unwrap_maybe_or_fail err_msg maybe =
  match maybe with
    | Just v -> return v
    | Nothing -> (* Error.fail err_msg *) failwith err_msg
  end

let unwrap_maybe maybe =
  unwrap_maybe_or_fail "unwrap_maybe: nothing" maybe

let assert_unwrap_result res =
  match res with
    | Success v -> v
    | Fail err -> failwith err
  end

let assert_unwrap_maybe maybe =
  assert_unwrap_result (unwrap_maybe maybe)

let get_file_abi f =
  let guessed_abi = List.find (fun abi ->
    abi.is_valid_elf_header f.elf64_file_header
  ) Abis.all_abis in
  match guessed_abi with
    | Just abi -> Gnu_ext_abi.gnu_extend (Abis.tls_extend abi)
    | Nothing -> failwith "output file does not conform to any known ABI"
  end

let load_memory_image f =
  let abi = get_file_abi f in
  elf_memory_image_of_elf64_file abi "<input file>" f

let load_memory_image_with_sections f =
  let f_without_phdr = <|
    elf64_file_header = f.elf64_file_header;
    elf64_file_program_header_table = [];
    elf64_file_section_header_table = f.elf64_file_section_header_table;
    elf64_file_interpreted_segments = f.elf64_file_interpreted_segments;
    elf64_file_interpreted_sections = f.elf64_file_interpreted_sections;
    elf64_file_bits_and_bobs = f.elf64_file_bits_and_bobs
  |> in
  load_memory_image f_without_phdr

let load_memory_image_with_annotations f =
  (* TODO: this is a hack *)
  let raw = load_memory_image f in
  let annotated = load_memory_image_with_sections f in
  <|
    elements = raw.elements;
    by_range = annotated.by_range;
    by_tag = annotated.by_tag
  |>

let print_elf64_phdr f =
  let _ = Missing_pervasives.errln "Program header:" in
  let _ = List.map (fun pent ->
    Missing_pervasives.errln (
      "  offset=0x" ^
      (hex_string_of_natural (natural_of_elf64_off pent.elf64_p_offset))
      ^ " addr=0x" ^
      (hex_string_of_natural (natural_of_elf64_addr pent.elf64_p_vaddr))
      ^ " filesz=0x" ^
      (hex_string_of_natural (natural_of_elf64_xword pent.elf64_p_filesz))
      ^ " memsz=0x" ^
      (hex_string_of_natural (natural_of_elf64_xword pent.elf64_p_memsz))
      ^ " flags=" ^
      (string_of_elf_segment_permissions (natural_of_elf64_word pent.elf64_p_flags))
    )
  ) f.elf64_file_program_header_table in
  ()

let get_exec_segments f =
  List.filter (fun seg ->
    let (r, w, x) = seg.elf64_segment_flags in
    x
  ) f.elf64_file_interpreted_segments

let get_segment_at f addr =
  let l = List.filter (fun seg ->
    addr >= seg.elf64_segment_base &&
      addr < seg.elf64_segment_base + seg.elf64_segment_size
  ) f.elf64_file_interpreted_segments in
  match l with
    | [seg] -> return seg
    | [] -> Error.fail ("get_segment_at: no segment found at " ^ (hex_string_of_natural addr))
    | _ -> Error.fail ("get_segment_at: multiple segments found at " ^ (hex_string_of_natural addr))
  end

val get_mmap_entry_at : list mmap_entry -> natural -> maybe mmap_entry
let get_mmap_entry_at mmap_table addr =
  let l = List.filter (fun e ->
    addr >= e.mmap_entry_start && addr < e.mmap_entry_end
  ) mmap_table in
  match l with
    | [e] -> Just e
    | [] -> Nothing
    | _ -> failwith ("get_mmap_entry_at: multiple NT_FILE entries found at " ^ (hex_string_of_natural addr))
  end

let read_nt_file_entries endian note_segs =
  Error.foldM (fun acc note_seg ->
    let note_name = name_string_of_elf64_note note_seg in
    let note_type = natural_of_elf64_word note_seg.elf64_note_type in
    if note_name = "CORE" && note_type = Elf_note.nt_file then
      Elf_note.read_elf64_nt_file endian note_seg.elf64_note_desc >>= fun nt_file ->
      let entries = List.map (fun e ->
        let _ = Missing_pervasives.errln "NT_FILE:" in
        let _ = Missing_pervasives.errln ("  start: " ^ (hex_string_of_natural (natural_of_elf64_xword e.elf64_nt_file_entry_start))) in
        let _ = Missing_pervasives.errln ("  end: " ^ (hex_string_of_natural (natural_of_elf64_xword e.elf64_nt_file_entry_end))) in
        let _ = Missing_pervasives.errln ("  offset: " ^ (hex_string_of_natural (natural_of_elf64_xword e.elf64_nt_file_entry_offset))) in
        let _ = Missing_pervasives.errln ("  filename: " ^ e.elf64_nt_file_entry_filename) in

        <|
          mmap_entry_start = natural_of_elf64_xword e.elf64_nt_file_entry_start;
          mmap_entry_end = natural_of_elf64_xword e.elf64_nt_file_entry_end;
          mmap_entry_offset = natural_of_elf64_xword e.elf64_nt_file_entry_offset;
          mmap_entry_path = e.elf64_nt_file_entry_filename
        |>
      ) nt_file.elf64_nt_file_entries in
      return (acc ++ entries)
    else
      return acc
  ) [] note_segs

let read_nt_procstat_vmmap endian note_segs =
  Error.foldM (fun acc note_seg ->
    let note_name = name_string_of_elf64_note note_seg in
    let note_type = natural_of_elf64_word note_seg.elf64_note_type in
    if note_name = "FreeBSD" && note_type = Elf_note.nt_procstat_vmmap then
      (* FreeBSD sticks an uint32_t at the begining with the struct size *)
      read_elf64_word endian note_seg.elf64_note_desc >>= fun (item_size, bs) ->
      let item_size_res =
        if natural_of_elf64_word item_size <> natural_of_hex "0x488" then (* This is sizeof(struct kinfo_vmentry) *)
          Error.fail ("read_nt_auxv_value: unsupported VMMAP struct size: " ^ (show item_size))
        else
          return ()
      in
      item_size_res >>= fun () ->

      Elf_note.read_elf64_nt_procstat_vmmap endian bs >>= fun entries ->

      let entries = List.map (fun e ->
        let _ = Missing_pervasives.errln "NT_PROCSTAT_VMMAP:" in
        let _ = Missing_pervasives.errln ("  start: " ^ (hex_string_of_natural (natural_of_elf64_xword e.elf64_nt_procstat_vmentry_start))) in
        let _ = Missing_pervasives.errln ("  end: " ^ (hex_string_of_natural (natural_of_elf64_xword e.elf64_nt_procstat_vmentry_end))) in
        let _ = Missing_pervasives.errln ("  offset: " ^ (hex_string_of_natural (natural_of_elf64_xword e.elf64_nt_procstat_vmentry_offset))) in
        let _ = Missing_pervasives.errln ("  path: " ^ e.elf64_nt_procstat_vmentry_path) in

        <|
          mmap_entry_start = natural_of_elf64_xword e.elf64_nt_procstat_vmentry_start;
          mmap_entry_end = natural_of_elf64_xword e.elf64_nt_procstat_vmentry_end;
          mmap_entry_offset = natural_of_elf64_xword e.elf64_nt_procstat_vmentry_offset;
          mmap_entry_path = e.elf64_nt_procstat_vmentry_path
        |>
      ) entries in

      return (acc ++ entries)
    else
      return acc
  ) [] note_segs

let read_nt_auxv_value endian note_segs f auxv_type =
  Error.foldM (fun value note_seg ->
    let note_name = name_string_of_elf64_note note_seg in
    let note_type = natural_of_elf64_word note_seg.elf64_note_type in
    if (note_name = "CORE" && note_type = Elf_note.nt_auxv)
        || (note_name = "FreeBSD" && note_type = Elf_note.nt_procstat_auxv) then
      let bs = note_seg.elf64_note_desc in
      let bs_res = if note_name = "FreeBSD" then
        (* FreeBSD sticks an uint32_t at the begining with the struct size *)
        read_elf64_word endian bs >>= fun (item_size, bs) ->
        if natural_of_elf64_word item_size <> 16 then (* This is sizeof(Elf64_Auxinfo) *)
          Error.fail ("read_nt_auxv_value: unsupported AUXV struct size: " ^ (show item_size))
        else
          return bs
      else
        return bs
      in
      bs_res >>= fun bs ->
      Auxv.read_all_elf64_auxv endian bs >>= fun note_auxv_list ->
      Error.foldM (fun value auxv ->
        if (natural_of_elf64_xword auxv.elf64_auxv_type) = auxv_type then
          let v = natural_of_elf64_xword auxv.elf64_auxv_value in
          match value with
            | Nothing -> return (Just v)
            | Just _ -> Error.fail ("read_nt_auxv_execfn: duplicate value for type " ^ (show auxv_type))
          end
        else
          return value
      ) value note_auxv_list
    else
      return value
  ) Nothing note_segs

let read_nt_prstatus endian note_segs =
  Error.foldM (fun value note_seg ->
    let note_name = name_string_of_elf64_note note_seg in
    let note_type = natural_of_elf64_word note_seg.elf64_note_type in
    if (note_name = "CORE" || note_name = "FreeBSD")
        && note_type = Elf_note.nt_prstatus then
      Auxv.read_elf64_prstatus endian note_seg.elf64_note_desc >>= fun prstatus ->
      return (Just prstatus)
    else
      return value
  ) Nothing note_segs

let get_segment_byte_sequence_at f addr =
  get_segment_at f addr >>= fun seg ->
  Byte_sequence.dropbytes (addr - seg.elf64_segment_base) seg.elf64_segment_body

let read_nt_auxv_execfn endian note_segs f =
  read_nt_auxv_value endian note_segs f Auxv.at_execfn >>= fun addr ->
  match addr with
    | Just addr ->
      get_segment_byte_sequence_at f addr >>= fun value_bs ->
      Elf_note.read_string value_bs >>= fun (s, _) ->
      return (Just s)
    | Nothing -> return Nothing
  end

(** `struct ps_strings` *)
(* TODO: move this somewhere else *)
type elf64_psstrings = <|
  elf64_psstrings_argvstr : elf64_addr; (** first of 0 or more argument strings *)
  elf64_psstrings_nargvstr : elf64_word; (** the number of argument strings *)
  elf64_psstrings_envstr : elf64_addr; (** first of 0 or more environment strings *)
  elf64_psstrings_nenvstr : elf64_word; (** the number of environment strings *)
|>

let read_elf64_psstrings endian bs =
  read_elf64_addr endian bs >>= fun (argvstr, bs) ->
  read_elf64_word endian bs >>= fun (nargvstr, bs) ->
  read_elf64_addr endian bs >>= fun (envstr, bs) ->
  read_elf64_word endian bs >>= fun (nenvstr, bs) ->
  return <|
    elf64_psstrings_argvstr = argvstr;
    elf64_psstrings_nargvstr = nargvstr;
    elf64_psstrings_envstr = envstr;
    elf64_psstrings_nenvstr = nenvstr;
  |>

let read_nt_procstat_psstrings_argv0 endian note_segs f =
  Error.foldM (fun value note_seg ->
    let note_name = name_string_of_elf64_note note_seg in
    let note_type = natural_of_elf64_word note_seg.elf64_note_type in
    if (note_name = "FreeBSD") && note_type = Elf_note.nt_procstat_psstrings then
      (* FreeBSD sticks an uint32_t at the begining with the struct size *)
      read_elf64_word endian note_seg.elf64_note_desc >>= fun (item_size, bs) ->
      if natural_of_elf64_word item_size <> 8 then Error.fail ("read_nt_procstat_psstrings: unsupported PSSTRINGS struct size: " ^ (show item_size)) else
      (* Triple indirection, just because we like it *)
      Elf_note.read_elf64_nt_procstat_psstrings endian bs >>= fun psstrings_addr ->
      let psstrings_addr = natural_of_elf64_addr psstrings_addr in
      get_segment_byte_sequence_at f psstrings_addr >>= fun psstrings_bs ->
      read_elf64_psstrings endian psstrings_bs >>= fun psstrings ->
      let argvstr_addr = natural_of_elf64_addr psstrings.elf64_psstrings_argvstr in
      get_segment_byte_sequence_at f argvstr_addr >>= fun argvstr_bs ->
      read_elf64_addr endian argvstr_bs >>= fun (argv0_addr, _) ->
      let argv0_addr = natural_of_elf64_addr argv0_addr in
      get_segment_byte_sequence_at f argv0_addr >>= fun argv0_bs ->
      Elf_note.read_string argv0_bs >>= fun (argv0str, _) ->
      return (Just argv0str)
    else
      return value
  ) Nothing note_segs

let load_file filename =
  let endian = Endianness.default_endianness in
  Byte_sequence.acquire filename >>= fun bs ->
  let read_uchar = Elf_types_native_uint.read_unsigned_char endian in
  Error.repeatM' Elf_header.ei_nident bs read_uchar >>= fun (ident, _) ->
  match List.index ident 4 with
    | Nothing -> Assert_extra.failwith "ELF ident transcription error"
    | Just c ->
      let c = Elf_types_native_uint.natural_of_unsigned_char c in
      if c = Elf_header.elf_class_64 then
        Elf_file.read_elf64_file bs >>= fun f ->
        return (bs, f)
      else
        Assert_extra.failwith "Unknown ELF ident"
  end

let print_memory_image img =
  let _ = Missing_pervasives.errln "Memory image:" in
  Map.mapi (fun k e ->
    let start = assert_unwrap_maybe e.startpos in
    let len = assert_unwrap_maybe e.length in
    Missing_pervasives.errln ("  element: " ^ k ^ " start=0x" ^ (hex_string_of_natural start) ^ " len=0x" ^ (hex_string_of_natural len) ^ " contents_len=0x" ^ (hex_string_of_natural (naturalFromNat (List.length e.contents))))
  ) img.elements

let find_memory_image_element f img =
  let elements = Map_extra.toList img.elements in
  List.foldl (fun maybe_res (_, e) ->
    let ok = f e in
    match maybe_res with
      | Just _ ->
        if ok then Nothing
        else maybe_res
      | Nothing ->
        if ok then Just e
        else maybe_res
    end
  ) Nothing elements

let memory_image_element_at img addr =
  find_memory_image_element (fun e ->
    let start = assert_unwrap_maybe e.startpos in
    let len = assert_unwrap_maybe e.length in
    addr >= start && addr < start + len
  ) img

val byte_pattern_skip : natural -> byte_pattern -> byte_pattern
let rec byte_pattern_skip offset bp =
  if offset < 0 then
    failwith "byte_pattern_skip: cannot skip a negative number of bytes"
  else if offset = 0 then
    bp
  else
    match bp with
      | _ :: bp -> byte_pattern_skip (offset - 1) bp
      | [] -> failwith "byte_pattern_skip: skipped past end"
    end

type byte_pattern_compare_result =
  | BytePatternMatch
  | BytePatternMismatch of (natural * string)

let rec compare_byte_pattern' offset core_bp binary_bp =
  match (core_bp, binary_bp) with
    | (_, []) ->
      BytePatternMatch
    | ((Just core_b)::core_bp, (Just binary_b)::binary_bp) ->
      if core_b <> binary_b then
        let err_msg = "compare_byte_pattern: mismatch at offset 0x" ^ (hex_string_of_natural offset) ^ ": byte " ^ (show core_b) ^ " vs. " ^ (show binary_b) in
        BytePatternMismatch (offset, err_msg)
      else
        compare_byte_pattern' (offset + 1) core_bp binary_bp
    | (_::core_bp, Nothing::binary_bp) ->
      compare_byte_pattern' (offset + 1) core_bp binary_bp
    | (maybe_core_b::_, maybe_binary_b::_) ->
      let err_msg = "compare_byte_pattern: mismatch at offset 0x" ^ (hex_string_of_natural offset) ^ ": " ^ (show maybe_core_b) ^ " vs. " ^ (show maybe_binary_b) in
      BytePatternMismatch (offset, err_msg)
    | (_, _) ->
      let err_msg = "compare_byte_pattern: mismatch at offset 0x" ^ (hex_string_of_natural offset) ^ ": length mismatch" in
      BytePatternMismatch (offset, err_msg)
  end

val compare_byte_pattern : byte_pattern -> byte_pattern -> byte_pattern_compare_result
let compare_byte_pattern = compare_byte_pattern' 0

val print_byte_pattern_line' : natural -> natural -> byte_pattern -> unit
let rec print_byte_pattern_line' offset len bp =
  if len = 0 then () else
  let (s, bp) = match bp with
    | [] -> ("  ", [])
    | maybe_b::bp ->
      let s = match maybe_b with
        | Nothing -> "--"
        | Just b -> show b
      end in
      (s, bp)
  end in
  let s = if offset mod 2 = 1 && (len - 1) > 0 then s ^ " " else s in
  let _ = Missing_pervasives.errs s in
  print_byte_pattern_line' (offset + 1) (len - 1) bp

val print_byte_pattern_line : natural -> byte_pattern -> unit
let print_byte_pattern_line = print_byte_pattern_line' 0

val fixed_hex_string_of_natural : natural -> natural -> string
let rec fixed_hex_string_of_natural len n =
    if len = 0 then ""
    else (fixed_hex_string_of_natural (len - 1) (n / 16)) ^ (toString [Missing_pervasives.hex_char_of_nibble (n mod 16)])

let print_byte_pattern_addr_size : natural = 12
let print_byte_pattern_line_size : natural = 16

val print_byte_pattern : natural -> byte_pattern -> unit
let rec print_byte_pattern start bp =
  if bp = [] then () else
  let _ = Missing_pervasives.errs ((fixed_hex_string_of_natural print_byte_pattern_addr_size start) ^ " ") in
  let (line, bp) = List.splitAt (natFromNatural print_byte_pattern_line_size) bp in
  let _ = print_byte_pattern_line print_byte_pattern_line_size line in
  let _ = Missing_pervasives.errs "\n" in
  print_byte_pattern (start + print_byte_pattern_line_size) bp

val print_two_byte_patterns : natural -> byte_pattern -> byte_pattern -> unit
let rec print_two_byte_patterns start bp1 bp2 =
  if bp1 = [] && bp2 = [] then () else
  let was_bp1_empty = bp1 = [] in (* If only bp1 is empty, print one extra line *)
  let _ = Missing_pervasives.errs ((fixed_hex_string_of_natural print_byte_pattern_addr_size start) ^ " | ") in
  let (line1, bp1) = List.splitAt (natFromNatural print_byte_pattern_line_size) bp1 in
  let (line2, bp2) = List.splitAt (natFromNatural print_byte_pattern_line_size) bp2 in
  let _ = print_byte_pattern_line print_byte_pattern_line_size line1 in
  let _ = Missing_pervasives.errs " | " in
  let _ = print_byte_pattern_line print_byte_pattern_line_size line2 in
  let _ = match compare_byte_pattern line2 line1 with
    | BytePatternMatch -> ()
    | BytePatternMismatch (_, err_msg) -> Missing_pervasives.errs " X" (* Missing_pervasives.errs (" " ^ err_msg) *)
  end in
  let _ = Missing_pervasives.errs "\n" in
  if was_bp1_empty then
    Missing_pervasives.errln "             |                                         |                   […]                  "
  else
    print_two_byte_patterns (start + print_byte_pattern_line_size) bp1 bp2

let get_section_at_offset f offset =
  let l = List.filter (fun sec ->
    offset >= sec.elf64_section_offset &&
      offset < sec.elf64_section_offset + sec.elf64_section_size
  ) f.elf64_file_interpreted_sections in
  match l with
    | [] -> Nothing
    | [sec] -> Just sec
    | _ -> failwith ("get_section_at_offset: multiple sections at offset 0x" ^ (hex_string_of_natural offset))
  end

let print_elf64_section sec =
  Missing_pervasives.errln (sec.elf64_section_name_as_string
    ^ " offset=0x" ^ (hex_string_of_natural sec.elf64_section_addr)
    ^ " addr=0x" ^ (hex_string_of_natural sec.elf64_section_addr)
    ^ " len=0x" ^ (hex_string_of_natural sec.elf64_section_size))

let get_section_at_addr f addr =
  if addr = 0 then Nothing else (* TODO: is this the right thing to do? *)
  let l = List.filter (fun sec ->
    addr >= sec.elf64_section_addr &&
      addr < sec.elf64_section_addr + sec.elf64_section_size
  ) f.elf64_file_interpreted_sections in
  match l with
    | [] -> Nothing
    | [sec] -> Just sec
    | sec::_ -> Just sec (* TODO: remove me *)
    (* | _ ->
      let _ = List.map print_elf64_section l in
      failwith ("get_section_at_addr: " ^ (show (List.length l)) ^ " sections at address 0x" ^ (hex_string_of_natural addr)) *)
  end

let show_section_at_addr f addr =
  match get_section_at_addr f addr with
    | Just section ->
      let offset_in_section = addr - section.elf64_section_addr in
      "[section at " ^ section.elf64_section_name_as_string ^ "+0x" ^ (hex_string_of_natural offset_in_section) ^ "]"
    | Nothing ->
      "[unknown section at 0x" ^ (hex_string_of_natural addr) ^ "]"
  end

val show_section_at : list mmap_entry -> elf64_file -> natural -> string
let show_section_at mmap_table f addr =
  match get_mmap_entry_at mmap_table addr with
    | Just e ->
      let entry_offset = e.mmap_entry_offset in
      let offset_in_entry = addr - e.mmap_entry_start in
      let file_offset = entry_offset + offset_in_entry in
      match get_section_at_offset f file_offset with
        | Just section ->
          let offset_in_section = file_offset - section.elf64_section_offset in
          "[section at 0x" ^ (hex_string_of_natural addr) ^ ", " ^ section.elf64_section_name_as_string ^ "+0x" ^ (hex_string_of_natural offset_in_section) ^ "]"
        | Nothing ->
          "[unknown section at 0x" ^ (hex_string_of_natural addr) ^ " with NT_FILE at 0x" ^ (hex_string_of_natural e.mmap_entry_start) ^ "]"
      end
    | Nothing ->
      "[unknown section at 0x" ^ (hex_string_of_natural addr) ^ " without NT_FILE]"
  end

let rec extract_memory_byte_pattern img start len =
  if len = 0 then return [] else
  let err_msg = "extract_memory_byte_pattern: no core image element at 0x" ^ (hex_string_of_natural start) in
  unwrap_maybe_or_fail err_msg (memory_image_element_at img start) >>= fun el ->
  let el_start = assert_unwrap_maybe el.startpos in
  let el_len = assert_unwrap_maybe el.length in
  let _ = Missing_pervasives.errln ("  Matching with core image element at 0x" ^ (hex_string_of_natural el_start) ^ ", length 0x" ^ (hex_string_of_natural el_len)) in
  let _ = Missing_pervasives.errln ("  Available for checking: 0x" ^ (hex_string_of_natural (naturalFromNat (List.length el.contents))) ^ " bytes") in
  let offset = start - el_start in
  (* let _ = Missing_pervasives.errln ("Skipping 0x" ^ (hex_string_of_natural offset) ^ " bytes") in *)
  let bp = byte_pattern_skip offset el.contents in
  let stop = start + len in
  let el_stop = el_start + el_len in
  if stop > el_stop then
    extract_memory_byte_pattern img el_stop (stop - el_stop) >>= fun next ->
    return (bp ++ next)
  else
    return bp

let compare_memory_image core_img binary_img (* for debugging: *) (mmap_table, binary_file) =
  let binary_elements = Map_extra.toList binary_img.elements in
  let results = List.map (fun (_, binary_el) ->
    let start = assert_unwrap_maybe binary_el.startpos in
    (* let len = assert_unwrap_maybe binary_el.length in *)
    let len = naturalFromNat (List.length binary_el.contents) in
    if len = 0 then return () else
    let _ = Missing_pervasives.errln ("Comparing memory element at 0x" ^ (hex_string_of_natural start) ^ ", length 0x" ^ (hex_string_of_natural len)) in

    let binary_bp = binary_el.contents in
    extract_memory_byte_pattern core_img start len >>= fun core_bp ->
    match compare_byte_pattern core_bp binary_bp with
      | BytePatternMatch ->
        let _ = Missing_pervasives.errln ("  Memory image element at 0x" ^ (hex_string_of_natural start) ^ " matches!") in
        return ()
      | BytePatternMismatch (mismatch_offset, err_msg) ->
        let mismatch_addr = start + mismatch_offset in
        let _ = Missing_pervasives.errln err_msg in
        let _ = Missing_pervasives.errln ("  Memory image element at 0x" ^ (hex_string_of_natural start) ^ " mismatches at offset 0x" ^ (hex_string_of_natural mismatch_addr) ^ " in " ^ (show_section_at mmap_table binary_file mismatch_addr) ^ " :(") in
        let _ = Missing_pervasives.errln "Addr         | Binary                                  | Core                                   " in
        let _ = print_two_byte_patterns start binary_bp core_bp in
        Error.fail "Mismatch"
    end
  ) binary_elements in
  let _ = List.map (fun res ->
    match res with
      | Success _ -> ()
      | Fail err -> Missing_pervasives.errln err
    end
  ) results in
  Error.foldM (fun _ res -> res) () results

val write_byte_pattern : byte_pattern -> natural -> byte_pattern -> byte_pattern
let write_byte_pattern bp offset sub_bp =
  if sub_bp = [] then bp else
  let len = List.length sub_bp in
  let (prefix, bp) = List.splitAt (natFromNatural offset) bp in
  let (old, suffix) = List.splitAt len bp in
  (* We don't want to change the byte pattern length *)
  let _ = if suffix = [] && List.length old <> len then failwith "write_byte_pattern: write past end" else () in
  prefix ++ sub_bp ++ suffix

val read_memory_image : forall 'abifeature. annotated_memory_image 'abifeature -> natural -> natural -> maybe (list byte)
let read_memory_image img start len =
  let stop = start + len in
  let elements = Map_extra.toList img.elements in
  List.foldl (fun maybe_field (_, el) ->
    let el_start = assert_unwrap_maybe el.startpos in
    (* let el_len = assert_unwrap_maybe el.length in *)
    let el_len = naturalFromNat (List.length el.contents) in (* TODO? *)
    let el_stop = el_start + el_len in
    (* Do not allow reading fields across elements *)
    if start >= el_start && stop <= el_stop then
      (* TODO: check consistency if maybe_field is not Nothing *)
      let offset = start - el_start in
      let bp = List.take (natFromNatural len) (List.drop (natFromNatural offset) el.contents) in
      let l = List.map (fun maybe_b ->
        match maybe_b with
          | Just b -> b
          | Nothing -> failwith "read_memory_image: attempted to read a masked byte"
        end
      ) bp in
      Just l
    else
      maybe_field
  ) Nothing elements

val write_memory_image : forall 'abifeature. annotated_memory_image 'abifeature -> natural -> byte_pattern -> annotated_memory_image 'abifeature
let write_memory_image img start bp =
  if bp = [] then img else
  let len = naturalFromNat (List.length bp) in
  let stop = start + len in
  let elements = Map.map (fun el ->
    let el_start = assert_unwrap_maybe el.startpos in
    (* let el_len = assert_unwrap_maybe el.length in *)
    let el_len = naturalFromNat (List.length el.contents) in (* TODO? *)
    let el_stop = el_start + el_len in
    let contents =
      if start >= el_start && start < el_stop then
        let write_start = start - el_start in
        let write_max_len = el_stop - start in
        let write_bp = List.take (natFromNatural write_max_len) bp in
        (* let _ = Missing_pervasives.errln ("  Masking at 0x" ^ (hex_string_of_natural el_start) ^ "+0x" ^ (hex_string_of_natural write_start) ^ " max_len=0x" ^ (hex_string_of_natural write_max_len) ^ " len=0x" ^ (hex_string_of_natural (naturalFromNat (List.length write_bp)))) in *)
        write_byte_pattern el.contents write_start write_bp
      else if stop >= el_start && stop < el_stop then
        (* Case el_start < start is handled above *)
        let _ = Assert_extra.ensure (el_start >= start) "write_memory_image: internal failure" in
        let write_bp = List.drop (natFromNatural (el_start - start)) bp in
        (* let _ = Missing_pervasives.errln ("  Masking at 0x" ^ (hex_string_of_natural el_start) ^ "+0 len=0x" ^ (hex_string_of_natural (naturalFromNat (List.length write_bp)))) in *)
        write_byte_pattern el.contents 0 write_bp
      else
        el.contents
    in
    <|
      startpos = Just el_start;
      length = Just el_len;
      contents = contents
    |>
  ) img.elements in
  <|
    elements = elements;
    by_range = img.by_range;
    by_tag = img.by_tag
  |>

let mask_memory_image img start len =
  if len = 0 then img else
  let bp = List.replicate (natFromNatural len) Nothing in
  write_memory_image img start bp

let is_data_section sec =
  false
  || sec.elf64_section_name_as_string = ".data"
  || sec.elf64_section_name_as_string = ".sdata" (* initialized short data *)
  || sec.elf64_section_name_as_string = ".sbss" (* uninitialized short data *)
  || sec.elf64_section_name_as_string = ".tdata" (* initialized thread-local data *)
  || sec.elf64_section_name_as_string = ".tbss" (* uninitialized thread-local data *)
  || sec.elf64_section_name_as_string = ".dynamic"
  || sec.elf64_section_name_as_string = ".data.rel.ro" (* TODO: remove me? *)
  || sec.elf64_section_name_as_string = ".rld_map" (* TODO: remove me *)

let mask_data_sections f img =
  let data_sections = List.filter is_data_section f.elf64_file_interpreted_sections in
  List.foldl (fun img sec ->
    let _ = Missing_pervasives.errln ("Masking " ^ sec.elf64_section_name_as_string ^ " at 0x" ^ (hex_string_of_natural sec.elf64_section_addr) ^ ", size 0x" ^ (hex_string_of_natural sec.elf64_section_size)) in
    mask_memory_image img sec.elf64_section_addr sec.elf64_section_size
  ) img data_sections

let mask_relocations f img =
  let all_relocs = Elf_memory_image.extract_all_relocs "<input file>" f in
  let abi = get_file_abi f in
  List.foldl (fun img (scn, rel_idx, rel_src_scn, rel) ->
    let addr = natural_of_elf64_addr rel.elf64_ra_offset in
    let (rel_type, _) = abi.parse_reloc_info rel.elf64_ra_info in
    let (is_absolute, applyfn) = abi.reloc rel_type in
    let (width, calcfn) = applyfn img addr Memory_image.null_symbol_reference_and_reloc_site in
    let _ = Missing_pervasives.errln ("Masking relocation of type 0x" ^ (hex_string_of_natural rel_type) ^ " at 0x" ^ (hex_string_of_natural addr) ^ ", size 0x" ^ (hex_string_of_natural width) ^ " in " ^ (show_section_at_addr f addr)) in
    (* let _ = Missing_pervasives.errln ("Relocation info: " ^ (show rel.elf64_ra_info)) in *)
    mask_memory_image img addr width
  ) img all_relocs

let extract_all_relocs_as_symbol_references abi f =
  let all_relocs = Elf_memory_image.extract_all_relocs "<input file>" f in
  let all_symtab_triples_by_scnidx = mapMaybei (fun scnidx -> (fun isec ->
    if isec.elf64_section_type = sht_symtab || isec.elf64_section_type = sht_dynsym then
      match find_elf64_symbols_by_symtab_idx scnidx f with
        | Fail _ -> Nothing
        | Success triple -> Just (scnidx, triple)
      end
    else Nothing
  )) f.elf64_file_interpreted_sections in
  let (all_extracted_symtabs_by_scnidx : (Map.map natural (list (string * elf64_symbol_table_entry * natural (* scnidx *) * natural (* symidx *))))) =
    List.foldl (fun acc ->
      (fun (scnidx, triple) ->
        Map.insert scnidx (Elf_memory_image.extract_all_symbols triple) acc
      )
    ) Map.empty all_symtab_triples_by_scnidx
  in
  (* let _ = Missing_pervasives.errln ("All extracted symtabs by scnidx: " ^ (show (Set_extra.toList (Map.toSet all_extracted_symtabs_by_scnidx)))) in *)
  let ref_for_relocation_a_in_section_index = fun rel_scn_idx -> (fun rel_idx -> (fun rela ->
    let rela_isec = match Missing_pervasives.index rel_scn_idx f.elf64_file_interpreted_sections with
      | Just x -> x
      | Nothing -> failwith "relocation references nonexistent section"
    end in
    let symtab_idx = rela_isec.elf64_section_link in
    (* TODO: some relocations don't have a symbol. We detect those with a NULL symtab_idx, but there might be a better way to do it? *)
    if symtab_idx = 0 then null_symbol_reference else
    match Map.lookup symtab_idx all_extracted_symtabs_by_scnidx with
      | Nothing -> failwith ("referenced symtab does not exist: " ^ (show symtab_idx))
      | Just quads ->
        let (_, sym_idx) = abi.parse_reloc_info rela.elf64_ra_info in
        let maybe_quad = Missing_pervasives.index sym_idx quads in
        match maybe_quad with
          | Just(symname, syment, scnidx, symidx) ->
            <|
              ref_symname = symname;
              ref_syment = syment;
              ref_sym_scn = symtab_idx;
              ref_sym_idx = sym_idx
            |>
          | Nothing ->
            failwith ("reloc references symbol that does not exist: 0x" ^ (hex_string_of_natural sym_idx))
            (*("reloc at index " ^ (show rel_idx) ^ " references symbol (index " ^ (show sym_idx) ^
            ") that does not exist: symtab (index " ^ (show symtab_idx) ^ ") has " ^ (show (length quads)) ^ " entries")*)
        end
    end
  )) in
  (*let _ = Missing_pervasives.errs ("Extracted " ^ (show (length all_relocs)) ^ " reloc references (rel_scn, rel_idx, src_scn): "
      ^ (show (List.map (fun (rel_scn, rel_idx, srcscn, rela) -> (rel_scn, rel_idx, srcscn)) all_relocs)) ^ "\n")
  in*)
  List.map (fun (scn, idx, srcscn, rela) ->
    <|
      (* NOTE that a reference is not necessarily to an undefined symbol! *)
      ref = ref_for_relocation_a_in_section_index scn idx rela;
      maybe_reloc = Just <|
        ref_relent = rela;
        ref_rel_scn = scn;
        ref_rel_idx = idx;
        ref_src_scn = srcscn (* what section does the reference come from? it's the 'info' link of the rel section header *)
      |>;
      maybe_def_bound_to = Nothing
    |>
  ) all_relocs

let find_sym syms name =
  List.foldl (fun maybe_sym (sym_name, sym_entry, sym_addr) ->
    if name = sym_name then
      Just (sym_entry, sym_addr)
    else
      maybe_sym
  ) Nothing syms

let is_unsupported_relocation_type f rel_type =
  (* TODO: add support for TLS relocs *)
  if Abi_amd64.header_is_amd64 f.elf64_file_header then
    rel_type = r_x86_64_irelative || rel_type = r_x86_64_tpoff64
      || rel_type = r_x86_64_dtpoff64 || rel_type = r_x86_64_dtpmod64
  else if Abi_mips64.header_is_mips64 f.elf64_file_header then
    rel_type = r_mips_tls_tprel64
  else
    false

val apply_relocation : forall 'abifeature. abi 'abifeature -> elf64_file -> annotated_memory_image 'abifeature -> natural -> elf64_relocation_a -> symbol_reference_and_reloc_site -> natural -> annotated_memory_image 'abifeature
let apply_relocation abi f img base reloc symref_and_reloc_site sym_addr =
  let (rel_type, _) = abi.parse_reloc_info reloc.elf64_ra_info in
  let offset = natural_of_elf64_addr reloc.elf64_ra_offset in
  let addend = integer_of_elf64_sxword reloc.elf64_ra_addend in
  let addr = base + offset in
  (* TODO: support is_absolute? *)
  let (is_absolute, applyfn) = abi.reloc rel_type in
  let (width, calcfn) = applyfn img addr symref_and_reloc_site in
  let _ = Missing_pervasives.errln ("Relocation of type 0x" ^ (hex_string_of_natural rel_type) ^ " at 0x" ^ (hex_string_of_natural addr) ^ " (offset 0x" ^ (hex_string_of_natural offset) ^ "), size 0x" ^ (hex_string_of_natural width) ^ " in " ^ (show_section_at_addr f offset)) in

  (* TODO: is there a way to make this nicer? *)
  if rel_type = 0 then
    let _ = Missing_pervasives.errln "  Skipping NONE relocation" in
    img
  else

  let is_in_data_section = match get_section_at_addr f offset with
    | Just sec -> is_data_section sec
    | Nothing -> false
  end in
  if is_in_data_section then
    let _ = Missing_pervasives.errln "  Relocation inside a data section, ignoring" in
    img
  else
    if is_unsupported_relocation_type f rel_type then
      let _ = Missing_pervasives.errln ("  Giving up on this one") in
      mask_memory_image img addr width
    else
      let existing_bytes = assert_unwrap_maybe (read_memory_image img addr width) in
      (* TODO: don't hardcode little endian *)
      let existing_value = Memory_image.natural_of_le_byte_list existing_bytes in
      let new_value = calcfn sym_addr addend existing_value in
      (* TODO: don't hardcode little endian *)
      let field_bytes = Memory_image.natural_to_le_byte_list_padded_to width new_value in
      let field_bp = List.map (fun b -> Just b) field_bytes in
      let _ = Missing_pervasives.errln ("  Relocating `" ^ symref_and_reloc_site.ref.ref_symname ^ "` (existing=0x" ^ (hex_string_of_natural existing_value) ^ " addend=" ^ (show addend) ^ ") to 0x" ^ (hex_string_of_natural new_value) ^ " (symbol address 0x" ^ (hex_string_of_natural sym_addr) ^ ")") in
      write_memory_image img addr field_bp

let apply_all_relocations f img base syms =
  let abi = get_file_abi f in
  let symbol_refs_and_reloc_sites = extract_all_relocs_as_symbol_references abi f in
  (* let tags_and_ranges = Multimap.lookupBy Memory_image_orderings.tagEquiv (SymbolRef(null_symbol_reference_and_reloc_site)) img.by_tag in *)
  let _ = Missing_pervasives.errln ("Number of symbol refs: " ^ (show (List.length symbol_refs_and_reloc_sites))) in
  (* let _ = List.map (fun (tag, maybe_range) -> *)
  List.foldl (fun img symref_and_reloc_site ->
    let reloc_site = match symref_and_reloc_site.maybe_reloc with
      | Nothing -> failwith "impossible: no reloc site during relocation"
      | Just rs -> rs
    end in

    let maybe_sym =
      (* TODO: remove these special cases, especially the last one *)
      if symref_and_reloc_site.ref.ref_symname <> "" then
        find_sym syms symref_and_reloc_site.ref.ref_symname
      else
        Nothing
    in

    (* TODO: hard fail if symbol name is non-empty but find_sym returns Nothing? *)
    let sym_addr = match maybe_sym with
      | Just (sym_entry, sym_addr) -> sym_addr
      | Nothing -> 0 (* This isn't pretty, but doing something else would be complicated *)
    end in

    apply_relocation abi f img base reloc_site.ref_relent symref_and_reloc_site sym_addr
  (* ) tags_and_ranges in *)
  ) img symbol_refs_and_reloc_sites

let mips64_address_size : natural = 8

val apply_mips64_local_got_relocations : forall 'abifeature. annotated_memory_image 'abifeature -> natural -> natural -> natural -> (annotated_memory_image 'abifeature * natural)
let rec apply_mips64_local_got_relocations img base got_entry_addr local_gotno =
  if local_gotno = 0 then (img, got_entry_addr) else
  let _ = Missing_pervasives.errln ("MIPS local .got relocation at 0x" ^ (hex_string_of_natural got_entry_addr) ^ " (remaining: " ^ (show local_gotno) ^ ")") in
  let width = mips64_address_size in
  let existing_bytes = assert_unwrap_maybe (read_memory_image img got_entry_addr width) in
  (* TODO: don't hardcode little endian *)
  let existing_value = Memory_image.natural_of_le_byte_list existing_bytes in
  let new_value = base + existing_value in
  (* TODO: don't hardcode little endian *)
  let field_bytes = Memory_image.natural_to_le_byte_list_padded_to width new_value in
  let field_bp = List.map (fun b -> Just b) field_bytes in
  let _ = Missing_pervasives.errln ("  Relocating MIPS64 local .got entry from 0x" ^ (hex_string_of_natural existing_value) ^ " to 0x" ^ (hex_string_of_natural new_value)) in
  let img = write_memory_image img got_entry_addr field_bp in
  apply_mips64_local_got_relocations img base (got_entry_addr + width) (local_gotno - 1)

val apply_mips64_global_got_relocations' : forall 'abifeature. abi 'abifeature -> elf64_file -> annotated_memory_image 'abifeature -> list (string * Elf_symbol_table.elf64_symbol_table_entry * natural) -> list (string * elf64_symbol_table_entry * natural (* scnidx *) * natural (* symidx *)) -> natural -> natural -> natural -> (annotated_memory_image 'abifeature * natural)
let rec apply_mips64_global_got_relocations' abi f img dynsyms syms base got_entry_addr symtabno =
  if symtabno = 0 then (img, got_entry_addr) else
  match syms with
    | (sym_name, sym_entry, scnidx, symidx) :: syms ->
      let reloc = <|
        elf64_ra_offset = elf64_addr_of_natural (got_entry_addr - base);
        elf64_ra_info = elf64_xword_lshift (elf64_xword_of_natural Abi_mips64_relocation.r_mips_jump_slot) 56;
        elf64_ra_addend = elf64_sxword_of_integer 0
      |> in

      (* TODO: unify this with normal relocs *)
      let maybe_sym =
        (* TODO: remove these special cases, especially the last one *)
        if sym_name <> "" then
          find_sym dynsyms sym_name
        else
          Nothing
      in

      let sym_addr = match maybe_sym with
        | Just (sym_entry, sym_addr) -> sym_addr
        | Nothing -> 0 (* This isn't pretty, but doing something else would be complicated *)
      end in

      (* let sym_addr = base + natural_of_elf64_addr sym_entry.elf64_st_value in *)
      let symref_and_reloc_site = null_symbol_reference_and_reloc_site in
      let img = apply_relocation abi f img base reloc symref_and_reloc_site sym_addr in

      apply_mips64_global_got_relocations' abi f img dynsyms syms base (got_entry_addr + mips64_address_size) (symtabno - 1)
    | _ -> failwith "apply_mips64_global_got_relocations': not enough symbols"
  end

let apply_mips64_global_got_relocations f img dynsyms base got_entry_addr symtab_addr gotsym symtabno =
  let symtab_triples = mapMaybei (fun scnidx isec ->
    if isec.elf64_section_addr = natural_of_elf64_addr symtab_addr then
      match find_elf64_symbols_by_symtab_idx scnidx f with
        | Fail _ -> Nothing
        | Success triple -> Just triple
      end
    else
      Nothing
  ) f.elf64_file_interpreted_sections in
  let (syms : list (string * elf64_symbol_table_entry * natural (* scnidx *) * natural (* symidx *))) =
    match symtab_triples with
      | [triple] -> Elf_memory_image.extract_all_symbols triple
      | [] -> failwith "apply_mips64_global_got_relocations: no .symtab found"
      | _ -> failwith "apply_mips64_global_got_relocations: multiple .symtab sections not supported for MIPS64"
    end
  in
  let syms = List.drop (natFromNatural gotsym) syms in
  let abi = get_file_abi f in
  apply_mips64_global_got_relocations' abi f img dynsyms syms base got_entry_addr (symtabno - gotsym)

(* MIPS uses an ugly packed form for GOT relocations. See musl's do_mips_relocs
   function. *)
let apply_mips64_got_relocations f img dynsyms base dyns =
  let maybe_got_offset = List.find (fun (tag, _) -> tag = Elf_dynamic.dt_pltgot) dyns in
  let got_offset = match maybe_got_offset with
    | Just (_, Address got) -> got
    | Nothing -> failwith "apply_mips64_got_relocations: missing DT_PLTGOT in .dynamic"
  end in
  let got_addr = base + natural_of_elf64_addr got_offset in
  let got_entry_addr = got_addr in

  (* Apply local .git relocs *)
  let maybe_local_gotno = List.find (fun (tag, _) ->
    tag = Abi_mips64_dynamic.abi_mips64_dt_local_gotno
  ) dyns in
  let (img, got_entry_addr) = match maybe_local_gotno with
    | Just (_, Numeric local_gotno) ->
      (* The first entry is reserved to hold the address of the entry point in
         the dynamic linker to call when lazy resolving text symbols. The second
         entry is reserved by DSOs linked with GNU's ld to hold the base address
         of the loaded DSO. GNU DSOs have the MSB of the second entry set to 1.
         IRL, some ld.so implementations skip both (uclibc), some relocate both
         (musl), so we'll just don't check those two.
         TODO: check the MSB of the second entry and only mask it if it's GNU. *)
      let reserved_num = 2 in
      let img = mask_memory_image img got_entry_addr (reserved_num * mips64_address_size) in
      let got_entry_addr = got_addr + reserved_num * mips64_address_size in
      let local_gotno = local_gotno - reserved_num in

      let _ = Missing_pervasives.errln ("Applying " ^ (show local_gotno) ^ " MIPS64 local .got relocations") in
      apply_mips64_local_got_relocations img base got_entry_addr local_gotno
    | Nothing ->
      let _ = Missing_pervasives.errln "Not applying MIPS64 .got relocations: missing DT_LOCAL_GOTNO" in
      (img, got_addr)
  end in

  (* Apply R_MIPS_JUMP_SLOT relocs *)
  let maybe_symtab_addr = List.find (fun (tag, _) ->
    tag = Elf_dynamic.dt_symtab
  ) dyns in
  let symtab_addr = match maybe_symtab_addr with
    | Just (_, Address symtab_addr) -> symtab_addr
    | Nothing -> failwith "apply_mips64_got_relocations: missing DT_SYMTAB in .dynamic"
  end in
  let maybe_gotsym = List.find (fun (tag, _) ->
    tag = Abi_mips64_dynamic.abi_mips64_dt_gotsym
  ) dyns in
  let gotsym = match maybe_gotsym with
    | Just (_, Numeric gotsym) -> gotsym
    | Nothing -> failwith "apply_mips64_got_relocations: missing DT_MIPS_GOTSYM in .dynamic"
  end in
  let maybe_symtabno = List.find (fun (tag, _) ->
    tag = Abi_mips64_dynamic.abi_mips64_dt_symtabno
  ) dyns in
  let symtabno = match maybe_symtabno with
    | Just (_, Numeric symtabno) -> symtabno
    | Nothing -> failwith "apply_mips64_got_relocations: missing DT_MIPS_SYMTABNO in .dynamic"
  end in
  let (img, got_entry_addr) = apply_mips64_global_got_relocations f img dynsyms base got_entry_addr symtab_addr gotsym symtabno in

  img

let get_first_mapped_address mmap_table filename =
  List.foldl (fun first e ->
    if e.mmap_entry_path <> filename then first else
    let start = e.mmap_entry_start in
    let len = e.mmap_entry_end - start in
    if len = 0 then first else
    match first with
      | Just first -> Just (if start < first then start else first)
      | Nothing -> Just start
    end
  ) Nothing mmap_table

let get_first_memory_image_address img =
  let elements = Map_extra.toList img.elements in
  List.foldl (fun first (_, e) ->
    if assert_unwrap_maybe e.length = 0 then first else
    let start = assert_unwrap_maybe e.startpos in
    match first with
      | Just first -> Just (if start < first then start else first)
      | Nothing -> Just start
    end
  ) Nothing elements

let get_segment_at_offset f offset =
  let l = List.filter (fun seg ->
    offset >= seg.elf64_segment_offset &&
      offset < seg.elf64_segment_offset + seg.elf64_segment_size
  ) f.elf64_file_interpreted_segments in
  match l with
    | [seg] -> Just seg
    | [] -> Nothing
    | _ -> failwith ("get_segment_at_offset: multiple segments found at offset 0x" ^ (hex_string_of_natural offset))
  end

(** Check that the offsets between sections are preserved.

    For each LOAD segment in the binary, compute the virtual address where it
    should have been loaded, check that a page has been mmapped there, and check
    that the mmapped file offset is correct. *)
let check_mmaped_memory_image mmap_table binary_filename binary_file binary_delta =
  (* TODO: check the file has been mmaped at only one place? *)
  Error.foldM (fun () seg ->
    if seg.elf64_segment_type <> Elf_program_header_table.elf_pt_load then return () else
    let seg_addr = seg.elf64_segment_base + binary_delta in
    (* let _ = Missing_pervasives.errln ("Checking LOAD segment at 0x" ^ (hex_string_of_natural seg.elf64_segment_base) ^ ", virtual address 0x" ^ (hex_string_of_natural seg_addr)) in *)
    match get_mmap_entry_at mmap_table seg_addr with
      | Just e ->
        if e.mmap_entry_path = binary_filename then
          let page_start = e.mmap_entry_start in
          let page_file_offset = e.mmap_entry_offset in
          (* let _ = Missing_pervasives.errln ("  Matching page has virtual address 0x" ^ (hex_string_of_natural page_start) ^ " and offset 0x" ^ (hex_string_of_natural page_file_offset)) in *)
          let seg_offset_in_page = seg_addr - page_start in
          (* let _ = Missing_pervasives.errln ("  Segment offset in page: 0x" ^ (hex_string_of_natural seg_offset_in_page)) in *)
          let expected_seg_file_offset = page_file_offset + seg_offset_in_page in
          if seg.elf64_segment_offset = expected_seg_file_offset then
            return ()
          else
            Error.fail ("check_mmaped_memory_image: LOAD segment at 0x" ^ (hex_string_of_natural seg.elf64_segment_base) ^ " has invalid offset: has 0x" ^ (hex_string_of_natural seg.elf64_segment_offset) ^ ", expected 0x" ^ (hex_string_of_natural expected_seg_file_offset))
        else
          Error.fail ("check_mmaped_memory_image: LOAD segment at 0x" ^ (hex_string_of_natural seg.elf64_segment_base) ^ " has been mmapped to another file: " ^ e.mmap_entry_path)
      | Nothing ->
        Error.fail ("check_mmaped_memory_image: LOAD segment at 0x" ^ (hex_string_of_natural seg.elf64_segment_base) ^ " has not been mmapped at 0x" ^ (hex_string_of_natural seg_addr))
    end
  ) () binary_file.elf64_file_interpreted_segments

let get_memory_image_delta img addr =
  let img_addr = assert_unwrap_maybe (get_first_memory_image_address img) in
  addr - img_addr

let translate_memory_image img offset =
  let elements = Map.map (fun e ->
    let start = assert_unwrap_maybe e.startpos in
    <|
      startpos = Just (start + offset);
      length = e.length;
      contents = e.contents
    |>
  ) img.elements in
  <|
    elements = elements;
    by_range = img.by_range;
    by_tag = img.by_tag
  |>

val get_memory_image_stats : forall 'abifeature. annotated_memory_image 'abifeature -> (natural * natural)
let get_memory_image_stats img =
  List.foldl (fun stats (_, el) ->
    List.foldl (fun (n_bytes, n_masked) maybe_b ->
      let masked = match maybe_b with
        | Just _ -> false
        | Nothing -> true
      end in
      (n_bytes + 1, if masked then n_masked + 1 else n_masked)
    ) stats el.contents
  ) (0, 0) (Map_extra.toList img.elements)

let read_dynamic bs f =
  let endian = get_elf64_header_endianness f.elf64_file_header in
  let sht = f.elf64_file_section_header_table in
  let shared_object = is_elf64_shared_object_file f.elf64_file_header in
  let os_additional_ranges = gnu_ext_os_additional_ranges in
  let os = gnu_ext_tag_correspondence_of_tag in
  let os_dyn = gnu_ext_elf64_value_of_elf64_dyn in
  (* TODO: do not hardcode these *)
  let (proc, proc_dyn) =
    if Abi_mips64.header_is_mips64 f.elf64_file_header then
      (
        Abi_mips64_dynamic.abi_mips64_tag_correspondence_of_tag,
        Abi_mips64_dynamic.abi_mips64_elf64_value_of_elf64_dyn
      )
    else
      (* These are no-ops *)
      (
        (fun _ -> Error.fail "tag_correspondence_of_tag: unknown tag"),
        (fun _ _ -> Error.fail "elf64_value_of_elf64_dyn: unknown tag")
      )
  in
  obtain_elf64_dynamic_section_contents f os_additional_ranges os proc bs >>= fun dyns ->
  get_string_table_of_elf64_dyn_section endian dyns sht bs >>= fun stbl ->
  Error.mapM (fun dyn ->
    let tag = naturalFromInteger (integer_of_elf64_sxword dyn.elf64_dyn_tag) in
    get_value_of_elf64_dyn shared_object dyn os_additional_ranges os_dyn proc_dyn stbl >>= fun dyn_value ->
    return (tag, dyn_value)
  ) dyns

let has_dynamic_section f =
  let dyn_secs = List.filter (fun sec ->
    natural_of_elf64_word sec.elf64_sh_type = Elf_section_header_table.sht_dynamic
  ) f.elf64_file_section_header_table in
  dyn_secs <> []

let extract_dynsyms f offset existing_syms =
  let results = List.mapi (fun scnidx scn ->
    let scnidx = naturalFromNat scnidx in
    if scn.elf64_section_type = sht_dynsym then
      find_elf64_symbols_by_symtab_idx scnidx f >>= fun triple ->
      let syms = Elf_memory_image.extract_all_symbols triple in
      let syms = List.filter (fun (sym_name, sym_entry, scnidx, symidx) ->
        let sym_binding = get_elf64_symbol_binding sym_entry in
        let sym_value = natural_of_elf64_addr sym_entry.elf64_st_value in
        (sym_binding = Elf_symbol_table.stb_global || sym_binding = Elf_symbol_table.stb_weak)
          (* TODO: is this acceptable? *)
          && sym_value <> 0
      ) syms in
      let syms = List.map (fun (sym_name, sym_entry, scnidx, symidx) ->
        (* let _ = Missing_pervasives.errln ("Library exports dynamic symbol: " ^ sym_name) in *)
        (sym_name, sym_entry, offset + natural_of_elf64_addr sym_entry.elf64_st_value)
      ) syms in
      let syms = List.foldl (fun syms sym ->
        let (sym_name, sym_entry, sym_addr) = sym in
        let sym_binding = get_elf64_symbol_binding sym_entry in
        match find_sym existing_syms sym_name with
          | Just (existing_entry, existing_addr) ->
            if get_elf64_symbol_binding existing_entry = Elf_symbol_table.stb_weak && sym_binding <> Elf_symbol_table.stb_weak then
              (* Existing symbol is weak and the new one isn't, replace it *)
              let _ = Missing_pervasives.errln ("Overriding weak symbol `" ^ sym_name ^ "`, 0x" ^ (hex_string_of_natural existing_addr) ^ " -> 0x" ^ (hex_string_of_natural sym_addr)) in
              sym :: syms
            else if natural_of_elf64_half existing_entry.elf64_st_shndx = 0 && natural_of_elf64_half sym_entry.elf64_st_shndx <> 0 then
              (* Existing symbol has an undefined ndx and the new one has a defined one, replace it *)
              (* TODO: why is this the right thing to do? *)
              let _ = Missing_pervasives.errln ("Overriding symbol with undefined ndx `" ^ sym_name ^ "`, 0x" ^ (hex_string_of_natural existing_addr) ^ " -> 0x" ^ (hex_string_of_natural sym_addr)) in
              sym :: syms
            else
              let _ = Missing_pervasives.errln ("Multiple definitions of " ^ sym_name ^ ", only keeping the first one") in
              syms
          | Nothing ->
            sym :: syms
        end
      ) [] syms in
      return syms
    else
      return []
  ) f.elf64_file_interpreted_sections in
  Error.foldM (fun all_syms res ->
    res >>= fun syms ->
    return (all_syms ++ syms)
  ) [] results

let rec find_library root_path ld_library_paths soname =
  match ld_library_paths with
    | [] ->
      Error.fail ("find_library: cannot find library `" ^ soname ^ "`")
    | dir :: ld_library_paths ->
      (* TODO: this is a hack to skip 32-bit library dirs. Instead we should load the DSO and check its header *)
      if Missing_pervasives.string_contains dir "32" then find_library root_path ld_library_paths soname else
      let filename = dir ^ "/" ^ soname in
      if Filesystem.file_exists (root_path ^ filename) then
        return filename
      else
        find_library root_path ld_library_paths soname
  end

let rec check_binary ldconfig_paths core_file core_img is_loaded root_path mmap_table dynsyms binary_filename =
  let binary_filepath = realpath (root_path ^ binary_filename) in
  let binary_filename = assert_unwrap_maybe (Missing_pervasives.string_suffix (naturalFromNat (String.stringLength root_path)) binary_filepath) in

  let _ = Missing_pervasives.errln ("Loading binary from " ^ binary_filepath) in
  load_file binary_filepath >>= fun (binary_bs, binary_file) ->
  let _ = Missing_pervasives.errln "Binary file:" in
  let _ = print_elf64_phdr binary_file in

  let binary_img = load_memory_image binary_file in
  let _ = Missing_pervasives.errln "Binary image:" in
  let _ = print_memory_image binary_img in

  let binary_img =
    if is_loaded then
      let binary_img = mask_data_sections binary_file binary_img in
      binary_img
    else
      let _ = Missing_pervasives.errln "Not masking memory image" in
      binary_img
  in

  let (n_bytes, n_masked) = get_memory_image_stats binary_img in
  let _ = Missing_pervasives.errln ((show n_bytes) ^ " bytes, " ^ (show n_masked) ^ " masked bytes after masking") in

  let _ = Missing_pervasives.errln ("Searching binary " ^ binary_filename ^ " in mmap table") in
  let errmsg = "check_binary: cannot find `" ^ binary_filename ^ "` in the mmap table" in
  unwrap_maybe_or_fail errmsg (get_first_mapped_address mmap_table binary_filename) >>= fun binary_addr ->
  let _ = Missing_pervasives.errln ("Binary has been mapped at 0x" ^ (hex_string_of_natural binary_addr)) in
  let binary_delta = get_memory_image_delta binary_img binary_addr in
  let _ = Missing_pervasives.errln ("Binary has delta 0x" ^ (hex_string_of_natural binary_delta)) in
  check_mmaped_memory_image mmap_table binary_filename binary_file binary_delta >>= fun () ->
  let _ = Missing_pervasives.errln "Translating binary image" in
  let binary_img = translate_memory_image binary_img binary_delta in
  let _ = Missing_pervasives.errln "Binary image after translation:" in
  let _ = print_memory_image binary_img in

  let _ = Missing_pervasives.errln ("Extracting dynamic symbols from " ^ binary_filename) in
  extract_dynsyms binary_file binary_delta dynsyms >>= fun binary_dynsyms ->
  let _ = Missing_pervasives.errln ("Binary exports " ^ (show (List.length binary_dynsyms)) ^ " dynamic symbols") in
  let dynsyms = dynsyms ++ binary_dynsyms in

  (* Result contains the number of linked libraries *)
  let linked_libs_res =
    if not is_loaded then
      let _ = Missing_pervasives.errln "Core file hasn't been loaded; not checking linked libraries" in
      return (0, [], [])
    else if not (has_dynamic_section binary_file) then
      let _ = Missing_pervasives.errln "Binary doesn't have a .dynamic section; not checking linked libraries" in
      return (0, [], [])
    else
      let _ = Missing_pervasives.errln "Checking linked libraries" in
      read_dynamic binary_bs binary_file >>= fun dyns ->
      let dyn_dt_needed = List.filter (fun (tag, _) -> tag = Elf_dynamic.dt_needed) dyns in
      let _ = Missing_pervasives.errln ("Found " ^ (show (List.length dyn_dt_needed)) ^ " linked libraries") in
      let dt_needed = List.map (fun (_, dyn_value) ->
        match dyn_value with
          | Library soname ->
            (* TODO: remove this hack *)
            let paths =
              if soname = "libc.so" && Abi_mips64.header_is_mips64 binary_file.elf64_file_header && Missing_pervasives.string_contains binary_filepath "musl" then
                ["/lib/mips64el-linux-musl"]
              else
                ldconfig_paths
            in
            let _ = Missing_pervasives.errln ("Searching needed library `" ^ soname ^ "`") in
            assert_unwrap_result (find_library root_path paths soname)
          | _ -> failwith "got a dt_needed with something else than a Library"
        end
      ) dyn_dt_needed in
      let res = Error.foldM (fun dynsyms library_filepath ->
        check_binary ldconfig_paths core_file core_img is_loaded root_path mmap_table dynsyms library_filepath
      ) dynsyms dt_needed in
      res >>= fun dynsyms ->
      return (naturalFromNat (List.length dyn_dt_needed), dynsyms, dyns)
  in

  linked_libs_res >>= fun (libs_count, dynsyms, dyns) ->
  let _ = Missing_pervasives.errln ("OK: " ^ (show libs_count) ^ " libraries linked to " ^ binary_filepath ^ " match!") in

  let binary_img =
    if is_loaded then
      let _ = Missing_pervasives.errln ("Applying relocations in " ^ binary_filename) in
      let binary_img = apply_all_relocations binary_file binary_img binary_delta dynsyms in
      let binary_img =
        if Abi_mips64.header_is_mips64 binary_file.elf64_file_header &&
            has_dynamic_section binary_file then
          apply_mips64_got_relocations binary_file binary_img dynsyms binary_delta dyns
        else
          binary_img
      in
      binary_img
    else
      binary_img
  in

  let (n_bytes, n_masked) = get_memory_image_stats binary_img in
  let _ = Missing_pervasives.errln ((show n_bytes) ^ " bytes, " ^ (show n_masked) ^ " masked bytes") in

  let _ = Missing_pervasives.errln ("Checking memory image of " ^ binary_filename) in
  let comparison_res = compare_memory_image core_img binary_img (mmap_table, binary_file) in

  match comparison_res with
    | Success () ->
      let _ = Missing_pervasives.errln ("OK: " ^ binary_filepath ^ " matches!") in
      return dynsyms
    | Fail msg ->
      Error.fail (binary_filepath ^ " mismatches: " ^ msg)
  end

let process_file core_filepath maybe_root_path maybe_binary_filename =
  let root_path = match maybe_root_path with
    | Just root_path -> root_path ^ "/"
    | Nothing -> ""
  end in

  Ldconfig.read_ldconfig_paths root_path >>= fun ldconfig_paths ->

  load_file core_filepath >>= fun (core_bs, core_file) ->
  let elf_type = natural_of_elf64_half core_file.elf64_file_header.elf64_type in
  if elf_type <> Elf_header.elf_ft_core then Error.fail ("process_file: `" ^ core_filepath ^ "` is not a core file") else
  let endian = get_elf64_header_endianness core_file.elf64_file_header in
  Elf_note.obtain_elf64_note_segments endian core_file.elf64_file_program_header_table core_bs >>= fun note_segs ->
  read_nt_file_entries endian note_segs >>= fun nt_file_entries ->
  read_nt_procstat_vmmap endian note_segs >>= fun nt_procstat_vmmap ->
  (* TODO: don't allow both mmap table types to be present at the same time *)
  let mmap_table = nt_file_entries ++ nt_procstat_vmmap in
  if List.null mmap_table then Error.fail ("process_file: mmap table of core file `" ^ core_filepath ^ "` is empty") else
  read_nt_auxv_execfn endian note_segs core_file >>= fun maybe_execfn ->
  read_nt_procstat_psstrings_argv0 endian note_segs core_file >>= fun maybe_psstrings_argv0 ->
  read_nt_prstatus endian note_segs >>= fun prstatus ->

  let maybe_detected_binary_filename = match maybe_execfn with
    | Just _ -> maybe_execfn
    | Nothing -> maybe_psstrings_argv0
  end in
  let _ = Missing_pervasives.errln ("Detected binary filename: " ^ (show maybe_detected_binary_filename)) in

  let binary_filename_res = match (maybe_binary_filename, maybe_detected_binary_filename) with
    | (Just binary_filename, Just detected_binary_filename) ->
      let _ =
        if binary_filename <> detected_binary_filename then
          Missing_pervasives.errln ("warning: binary filename `" ^ binary_filename ^ "` mismatches detected filename `" ^ detected_binary_filename ^ "`")
        else
          ()
      in
      return binary_filename
    | (Just binary_filename, Nothing) -> return binary_filename
    | (Nothing, Just detected_binary_filename) -> return detected_binary_filename
    | (Nothing, Nothing) ->
      Error.fail "process_file: cannot detect binary filename in ELF notes, please provide it"
  end in
  binary_filename_res >>= fun binary_filename ->

  let _ = Missing_pervasives.errln "Core file:" in
  let _ = print_elf64_phdr core_file in

  let core_img = load_memory_image core_file in
  let _ = Missing_pervasives.errln "Core image:" in
  let _ = print_memory_image core_img in

  (* Data sections have to be masked if coredump has been generated after _start *)
  (* TODO: add a flag instead of this hacky thing *)
  let is_loaded = not (Missing_pervasives.string_contains core_filepath "start") in

  check_binary ldconfig_paths core_file core_img is_loaded root_path mmap_table [] binary_filename >>= fun _ ->

  return ()

let _ =
  let args = match Missing_pervasives.argv with
    | _::args -> args
    | _ -> []
  end in
  let (core_filepath, maybe_root_path, maybe_binary_filename) = match args with
    | [core_filepath] -> (core_filepath, Nothing, Nothing)
    | [core_filepath; root_path] -> (core_filepath, Just root_path, Nothing)
    | [core_filepath; root_path; binary_filename] -> (core_filepath, Just root_path, Just binary_filename)
    | _ -> Assert_extra.failwith "usage: main_load <core-file> [root] [binary-filename]"
  end in
  match process_file core_filepath maybe_root_path maybe_binary_filename with
    | Fail err -> failwith err
    | Success () -> Missing_pervasives.errln "OK: ALL GREEN"
  end
